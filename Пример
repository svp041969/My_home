никто не пишет, в пайтоне это делают так:

for news_item in news:
    if news_item.find('span', class_='time2 time3') is not None:
        new_news.append(news_item.text)


А если кроме самого элемента нужно иметь и доступ к индексу, то пользуются enumerate:
for i, news_item in enumerate(news):
    print(i, news_item)


---------------------------
import json

x = {
"name": "Виктор"
}
y = {
"name": "Виктор"
}
print(json.dumps(x))
print(json.dumps(y, ensure_ascii=False))
Вывод:

{"name": "\u0412\u0438\u043a\u0442\u043e\u0440"}
{"name": "Виктор"}
------------------------------------------------
zip
Напоследок ещё одна клёвая штука. Когда-нибудь возникала необходимость создать словарь из двух списков?

keys = ['a', 'b', 'c']
vals = [1, 2, 3]
zipped = dict(zip(keys, vals))
Встроенная функция zip() принимает несколько итерируемых объектов и возвращает последовательность  кортежей. Каждый кортеж группирует элементы объектов по их индексу.

Можно провести операцию, обратную zip(), с помощью zip(*).
---------------------------------------

all и any
Одна из многих причин популярности Python — его читабельность и выразительность.

Часто шутят, что Python — это «исполняемый псевдокод». Однако когда вы можете писать код таким образом, становится сложно не согласиться:

x = [True, True, False]
if any(x):
    print("Как минимум один True")

if all(x):
    print("Ни одного False")

if any(x) and not all(x):
    print("Как минимум один True и один False")
---------------------------------------------------
**kwargs
Когда изучаешь любой язык, на пути встречается множество краеугольных камней. В случае с Python понимание таинственного синтаксиса **kwargs можно считать одним из них.

Две звёздочки впереди объекта словаря дают возможность передавать в функцию содержимое этого словаря как именованные аргументы.

Ключи словаря — это имена аргументов, а значения передаются в функцию. Вам даже не обязательно называть его kwargs:

dictionary = {"a": 1, "b": 2}

def some_function(a, b):
    print(a + b)
    return

# оба варианта делают одно и то же:
some_function(**dictionary)
some_function(a=1, b=2)
Это полезно в тех случаях, когда ваши функции должны обрабатывать именованные аргументы, не определённые заранее.
------------------------------
Генераторы списков
Ещё одна классная особенность Python, дающая возможность быстро создавать списки. Такие выражения позволяют легко писать чистый код, который читается почти как естественный язык:

numbers = [1, 2, 3, 4, 5, 6, 7]
evens = [x for x in numbers if x % 2 == 0]
odds = [y for y in numbers if y not in evens]

cities = ['Лондон', 'Москва', 'Берлин']

def visit(city):
    print("Добро пожаловать в", city)

for city in cities:
    visit(city)
-------------------------------------
